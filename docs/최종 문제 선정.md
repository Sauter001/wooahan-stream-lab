```table-of-contents
```

# 클래스 정보

## Student
```java
class Student {
    private String name;
    private int grade;        // 학년 (1, 2, 3)
    private String subject;   // 과목 (Math, English, Science)
    private int score;        // 점수 (0~100)
    private String gender;    // 성별 (M, F)
    
    // constructor, getter 만들기
    public Student(String name, int grade, String subject, int score, String gender) {
        this.name = name;
        this.grade = grade;
        this.subject = subject;
        this.score = score;
        this.gender = gender;
    }
    
    // getter들...
}
```
## 주문 상품
### Product

```java
class Product {
    private String name;
    private String category;  // Electronics, Food, Clothing
    private int price;
    private int stock;
    
    // constructor, getter 만들기
}
```

### Order

```java
class Order {
    private String orderId;
    private String productName;
    private int quantity;
    private int price;
    private String customerName;
    private LocalDate orderDate;
    
    // constructor, getter 만들기
}
```

## RPG Game
### Guild

```java
class Guild {
    private Long id;
    private String name;
    private int level;
    private String region;
    // getters, constructors
}
```

### GameCharacter

```java
class GameCharacter {
    private Long id;
    private String name;
    private int level;
    private String characterClass; // "Warrior", "Mage", "Archer" 등
    private Guild guild;
    private List<Item> inventory;
    private int gold;
    private boolean isActive;
    // getters, constructors
}
```
### Item

```java
class Item {
    private Long id;
    private String name;
    private String rarity; // "Common", "Rare", "Epic", "Legendary"
    private int price;
    private String type; // "Weapon", "Armor", "Potion" 등
    private int power;
    // getters, constructors
}
```

## 서점

### 장르
```java
// (이 클래스들이 있다고 가정)
enum Genre { FICTION, NON_FICTION, SCIENCE, HISTORY, FANTASY, PROGRAMMING }
```

### 작가
```java
class Author {
    String name;
    int birthYear;
    String nationality;
    
    public String getName() { return name; }
    public int getBirthYear() { return birthYear; }
    public String getNationality() { return nationality; }
    // (equals, hashCode는 name 기반으로 오버라이드 되어있다고 가정)
}
```

### 책
```java
class Book {
    String title;
    List<Author> authors; // N:M (공저자)
    int publishYear;
    double price;
    Genre genre;
}
```

### 사용자

```java
class BookUser {
    String username;
    int age;
    List<Book> readBooks; // 1:N
    
    public String getUsername() { return username; }
    public int getAge() { return age; }
    public List<Book> getReadBooks() { return readBooks; }
}

// (List<Book> books, List<Author> authors, List<User> users 변수가 있다고 가정)
```
# 1단계

## 문제 1-1: 필터링 기본

```java
List<Student> students = Arrays.asList(
    new Student("김철수", 1, "Math", 85, "M"),
    new Student("이영희", 2, "Math", 92, "F"),
    new Student("박민수", 1, "English", 78, "M"),
    new Student("최지원", 2, "Science", 95, "F"),
    new Student("정다은", 3, "Math", 88, "F")
);
```

**할 일:**

1. 80점 이상인 학생들의 이름만 리스트로 반환
2. 2학년 학생들의 이름만 Set으로 반환 (중복 제거)
3. 여학생(F)들 중 90점 이상인 학생의 이름 리스트

## 문제 1-2: `map 변환`

```java
List<Product> products = Arrays.asList(
    new Product("노트북", "Electronics", 1200000, 5),
    new Product("마우스", "Electronics", 30000, 50),
    new Product("사과", "Food", 3000, 100),
    new Product("티셔츠", "Clothing", 25000, 30)
);
```

**할 일:**

1. 모든 상품 이름을 대문자로 변환한 리스트
2. 가격이 50000원 이하인 상품들의 카테고리만 Set으로 (중복 제거)
3. Electronics 카테고리 상품들의 재고 수량 리스트

## 문제 1-3: 종합

1. 활성 캐릭터 이름 5개만 가져오기
	- `List<Character> characters`가 주어졌을 때 `isActive`가 true인 캐릭터의 이름을 최대 5개만 `List<String>`으로 반환
	- **힌트**: `filter()` → `map()` → `limit(5)` → `collect()`
2. 레벨 순으로 정렬된 캐릭터 리스트
	- 모든 캐릭터를 레벨 내림차순으로 정렬한 `List<Character>` 반환
	- **힌트**: `sorted(Comparator.comparingInt(Character::getLevel).reversed())` + `collect()`
3. 중복 제거된 길드 이름 리스트
	- 모든 캐릭터가 속한 길드의 이름을 중복 없이 `List<String>`으로 반환
	- **힌트**: `map()` → `distinct()` → `collect()`
# 2단계

`flatMap`, `skip`, 복잡한 filter 다룸.

---
1. 레벨 30 이상이면서 길드에 속한 캐릭터의 이름을 알파벳 순으로
	- `filter()` 두 번 → `map()` → `sorted()` → `collect()`
2. 레벨이 가장 높은 상위 10명의 평균 gold를 Double로 반환
	- `sorted()` → `limit(10)` → `collect(Collectors.averagingInt())`
3. 모든 캐릭터의 인벤토리에 있는 아이템 이름을 중복 없이 쉼표로 구분한 String 반환
	- `flatMap()` → `map()` → `distinct()` → `collect(Collectors.joining(", "))` 
4. 캐릭터가 얻은 점수에 따라 1~3등은 골드 트로피, 4~10등: 실버 트로피를 수여한다. 실버 트로피를 받을 캐릭터 목록을 반환하라
	- 점수 기준 내림차순 정렬 → `skip(3)` → `limit(7)` → `collect()`
5. 레벨 50 이상이면서 gold가 5000 이상인 캐릭터가 존재하는지 boolean 반환
	- `filter()` → `filter()` → `anyMatch()` 또는 `findFirst().isPresent()`

# 3단계

좀 더 고급 수준의 collector 활용

---
1. `Student`에 대해 학년별로 학생들을 그룹화 (`Map<Integer, List<Student>>`)
2. 학생들의 과목별 평균 점수 (`Map<String, Double>`)
	- `collect(groupingBy(averagingInt()))`
3. 학년별 → 각 학년의 과목별 학생 수
	- 결과 타입: `Map<Integer, Map<String, Long>>`
4. 점수가 80점 이상/미만인 학생으로 분할 (`Map<Boolean, List<Student>>`)

다음 상품 리스트에 대해
```java
List<Product> duplicateProducts = Arrays.asList(
	new Product("노트북", "Electronics", 1200000, 5),
	new Product("노트북", "Electronics", 1500000, 3),  // 중복!
	new Product("마우스", "Electronics", 30000, 50)
);
```

5. 상품명을 key로, 가장 비싼 가격을 value로 하는 `Map
    - 힌트: `toMap(keyMapper, valueMapper, mergeFunction)`
6. 카테고리를 key로, 해당 카테고리의 총 재고를 value로 하는 `Map`
7. `(상점, 카테고리, 가격)`을 담은 `Transaction` 객체 리스트가 있다. Stream '한 줄'로 `Map<String, Map<String, Double>>`을 만들어라. 즉, **상점별**로 그룹화하고, 그 안에서 다시 **카테고리별**로 그룹화한 뒤, 각 카테고리의 **총합(sum)**을 계산하라.

# 4단계

collector, intermediate methods 복합. 반복문으로 할 시 간단한 문제를 stream으로 풀기

1. 어떤 문자열이 팰린드롬인지 판단하는 `boolean` 결과
2. 정수 리스트(`List<Integer>`)가 주어질 때 이 리스트의 모든 부분집합(subset)을 요소로 하는 `Set<Set<T>>`(멱집합)를 구하라.
3. 레벨 오름차순으로 정렬한 뒤, 동일 레벨 캐릭터 중 첫 번째만 남긴 `List<GameCharacter>` 반환
4. Guild를 키로, 해당 길드 소속 캐릭터 중 레벨 상위 3명의 레벨 합계를 값으로 하는 `Map<Guild, Integer>` 반환

다음 형태의 데이터에 대해
```java
List<Order> orders = Arrays.asList(
    new Order("O001", "노트북", 2, 1200000, "김철수", LocalDate.of(2025, 1, 15)),
    new Order("O002", "마우스", 5, 30000, "이영희", LocalDate.of(2025, 1, 16)),
    new Order("O003", "노트북", 1, 1200000, "박민수", LocalDate.of(2025, 2, 10)),
    new Order("O004", "키보드", 3, 80000, "김철수", LocalDate.of(2025, 2, 11)),
    new Order("O005", "마우스", 2, 30000, "최지원", LocalDate.of(2025, 3, 5)),
    new Order("O006", "노트북", 1, 1200000, "김철수", LocalDate.of(2025, 3, 20))
);
```

5. **월별 베스트셀러** (`Map<Integer, String>`)
    - 각 월(1, 2, 3)의 가장 많이 팔린 상품 이름 집계
    - 힌트: `groupingBy` → 각 그룹에서 `maxBy`
6. **VIP 고객 필터링**
    - 총 구매액이 2,000,000원 이상인 고객 리스트
    - 구매 횟수가 2회 이상인 고객 리스트
    - **위 두 조건을 모두 만족하는** 고객 Set

# 5단계

1. 리스트의 리스트, `List<List<T>>` (예: `[[1, 2], ["A", "B"], [true]]`)가 주어졌을 때, 각 리스트에서 원소를 하나씩 뽑아 만들 수 있는 모든 조합(튜플)의 리스트 `List<List<T>>`를 반환하라. (데카르트곱 결과 반환)
2. 정수 리스트가 주어졌을 때 연속 부분합의 최댓값 구하기
	- 예: `[-2,1,-3,4,-1,2,1,-5,4]` 이면 `6 (부분합 [4,-1,2,1])`
3. 각 아이템 타입별 최고 power 아이템 (중복 제거, 상위 5개 타입만)
	- 프로세스
		- 모든 캐릭터의 인벤토리에서 아이템을 추출하여 type별로 그룹화한 뒤,
		- 각 타입에서 power가 가장 높은 아이템을 찾고, 
		- 그 power를 기준으로 상위 5개 타입만 `Map<String, Item>`으로 반환
	- 힌트: `flatMap()` → `distinct()` → `groupingBy()` + `maxBy()` → Map 스트림 변환 → `sorted()` → `limit(5)` → `collect()`
4. game character 중 인벤토리에 rarity가 "Rare", "Epic", "Legendary" 중 하나인 아이템이 3개 이상인 캐릭터를 소속 길드의 레벨 내림차순으로 정렬하여 이름만 `List<String>`으로 반환
5. **Custom collector을 구현하여** 정수 리스트를 N개씩 묶기
	- 입력: `[1,2,3,4,5,6,7], N=3` → `[[1,2,3], [4,5,6], [7]]`

# Secret phase

## 1. 정수로 구성된 집합에 대해 모든 순열의 경우의 수 반환하기
	- 입력: `[1, 2, 3]` → `[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]`

## 2. 무한 스트림 활용한 피보나치 수열 구현

- 예시: `Stream<Integer> infiniteStream = Stream.iterate(1, n -> n + 1);`
- ---

1. 1000 이하의 피보나치 수열 반환

2. 3중 중첩 정수 리스트 `List<List<List<Integer>>>`에 대해 
	1. 모든 레벨을 평탄화 
	2. 소수만 필터 
	3. 각 소수 n에 대해, n보다 작은 소수들의 개수를 계산 
	4. 그 개수(count)별로 그룹화 * 5. 각 그룹에서 가장 큰 소수를 찾아서 
	5. `Map<개수, 최대소수>` 반환

## 3. 1000만 개의 정수 배열 처리

1. 에라토스테네스의 체로 소수 판별 (배열 활용) 
2. 골드바흐 추측 검증: 모든 짝수는 두 소수의 합 
3. 각 소수에 대해, 그것을 포함하는 골드바흐 쌍의 개수 계산 
4. 가장 많이 사용된 상위 100개 소수의 합 반환

(단 에라토스테네스의 체 처리 매소드는 인터페이스의 메소드에서 꺼내쓸 수 있음)
### 제약

 * 0.3초 안에 완료 (`parallelStream` 필수)
 * 추가 배열/리스트 생성 최소화 (statement는 5개까지만 선언 가능)
 * Stream API만 사용


## 4. State monad 활용
### State Monad의 핵심 연산: 

* `get()` : 현재 상태를 읽기 
- `put(s)` : 상태를 s로 설정 
* `modify(f)` : 상태를 f 함수로 변환 
- `flatMap()` : State 계산을 연결

### State Monad 코드
```java
/**
 * State Monad 구현
 * State<S, A> = S -> (A, S)
 * S = State 타입, A = 결과 타입
 */
class State<S, A> {
    private final Function<S, Pair<A, S>> runState;
    
    public State(Function<S, Pair<A, S>> runState) {
        this.runState = runState;
    }
    
    // State 계산 실행
    public Pair<A, S> run(S initialState) {
        return runState.apply(initialState);
    }
    
    // Functor: map
    public <B> State<S, B> map(Function<A, B> f) {
        return new State<>(s -> {
            Pair<A, S> result = runState.apply(s);
            return new Pair<>(f.apply(result.first()), result.second());
        });
    }
    
    // Monad: flatMap
    public <B> State<S, B> flatMap(Function<A, State<S, B>> f) {
        return new State<>(s -> {
            Pair<A, S> result = runState.apply(s);
            return f.apply(result.first()).run(result.second());
        });
    }
    
    // 현재 상태 읽기
    public static <S> State<S, S> get() {
        return new State<>(s -> new Pair<>(s, s));
    }
    
    // 상태 설정
    public static <S> State<S, Unit> put(S newState) {
        return new State<>(s -> new Pair<>(Unit.INSTANCE, newState));
    }
    
    // 상태 변환
    public static <S> State<S, Unit> modify(Function<S, S> f) {
        return new State<>(s -> new Pair<>(Unit.INSTANCE, f.apply(s)));
    }
    
    // Pure value (return)
    public static <S, A> State<S, A> pure(A value) {
        return new State<>(s -> new Pair<>(value, s));
    }
}
```

### 문제: 후위 표기법 계산기

* 상태: `Stack<Integer>` (스택) 
* 입력: `List<String>` (명령어 리스트) 
* 출력: Integer (최종 결과) 
* * 예시: 
	* `["3", "4", "+", "2", "*"]` → `((3 + 4) * 2) = 14` 
	* `["15", "7", "1", "1", "+", "-", "*"]` → `(15 * (7 - (1 + 1))) = 75`

## 5. Either monad 활용

* `Either<L, R>`는 두 가지 값 중 하나를 가지는 타입: 
	* `Left<L>` : 실패 (에러) 
	- `Right<R>` : 성공 (값)
- try-catch 금지
### 단계
#### 5.1 정수 파싱

* `"123"` → `Right(123) `
* `"abc"` → `Left("Not a number: abc")`

#### 5.2, 5.3 체이닝할 양수 검증, 범위 검증

- `Integer num`에 대해 양수 검증. `Either<String, Integer>` 반환
- 파라미터 `Integer num`, `int min`, `int max`에서 `[min, max]` 구간 포함 여부 검증
#### 5.4 백분율 표기 변환 파이프 라인 구현 (이전 메소드 활용)
* `"50"` → `Right("50%")` 
* `"150"` → `Left("Out of range: 150")` 
* `"abc"` → `Left("Not a number: abc")`